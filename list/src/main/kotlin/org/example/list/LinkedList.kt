/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example.list

class LinkedList : List<String> {
    private var head: Node? = null

    // Node definition
    private data class Node(
        val data: String,
    ) {
        var next: Node? = null
    }

    // Add element
    fun add(element: String) {
        val newNode = Node(element)
        val it = tail(head)
        if (it == null) head = newNode else it.next = newNode
    }

    private fun tail(head: Node?): Node? {
        var it = head
        while (it?.next != null) it = it.next
        return it
    }

    fun remove(element: String): Boolean {
        var result = false
        var previousIt: Node? = null
        var it: Node? = head
        while (it != null) {
            if (it.data == element) {
                result = true
                unlink(previousIt, it)
                break
            }
            previousIt = it
            it = it.next
        }
        return result
    }

    private fun unlink(
        previousIt: Node?,
        currentIt: Node,
    ) {
        if (currentIt == head) head = currentIt.next else previousIt?.next = currentIt.next
    }

    override val size: Int
        get() {
            var size = 0
            var it = head
            while (it != null) {
                ++size
                it = it.next
            }
            return size
        }

    override fun isEmpty(): Boolean = head == null

    override fun contains(element: String): Boolean {
        var it = head
        while (it != null) {
            if (it.data == element) return true
            it = it.next
        }
        return false
    }

    override fun containsAll(elements: Collection<String>): Boolean {
        for (e in elements) if (!contains(e)) return false
        return true
    }

    override fun get(index: Int): String {
        if (index < 0) throw IndexOutOfBoundsException("Index: $index")
        var idx = index
        var it = head
        while (idx > 0 && it != null) {
            it = it.next
            idx--
        }
        if (it == null) throw IndexOutOfBoundsException("Index: $index")
        return it.data
    }

    override fun indexOf(element: String): Int {
        var idx = 0
        var it = head
        while (it != null) {
            if (it.data == element) return idx
            it = it.next
            idx++
        }
        return -1
    }

    override fun lastIndexOf(element: String): Int {
        var idx = 0
        var lastIdx = -1
        var it = head
        while (it != null) {
            if (it.data == element) lastIdx = idx
            it = it.next
            idx++
        }
        return lastIdx
    }

    override fun iterator(): Iterator<String> =
        object : Iterator<String> {
            private var current = head

            override fun hasNext() = current != null

            override fun next(): String {
                val data = current?.data ?: throw NoSuchElementException()
                current = current?.next
                return data
            }
        }

    override fun listIterator(): ListIterator<String> = listIterator(0)

    override fun listIterator(index: Int): ListIterator<String> {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        val snapshot = this.toList()
        return object : ListIterator<String> {
            private var pos = index

            override fun hasNext() = pos < snapshot.size

            override fun next(): String {
                if (!hasNext()) throw NoSuchElementException()
                return snapshot[pos++]
            }

            override fun hasPrevious() = pos > 0

            override fun previous(): String {
                if (!hasPrevious()) throw NoSuchElementException()
                return snapshot[--pos]
            }

            override fun nextIndex() = pos

            override fun previousIndex() = pos - 1
        }
    }

    override fun subList(
        fromIndex: Int,
        toIndex: Int,
    ): List<String> {
        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) throw IndexOutOfBoundsException()
        val result = mutableListOf<String>()
        var idx = 0
        var it = head
        while (it != null && idx < toIndex) {
            if (idx >= fromIndex) result.add(it.data)
            it = it.next
            idx++
        }
        return result
    }
}
